[<- Índice](../../../Pentesting.md)
# Simple Network Management Protocol

> ***SNMP*** (*Simple Network Management Protocol*) fue creado para monitorear dispositivos de red, administrar la configuración de tareas y activar ajustes de manera remota.

Entre los dispositivos que ***SNMP*** soporta, por ejemplo, son *Routers*, *Switches*, *Servidores*, *Dispositivos IoT*, etc.

La **versión actual** de este protocolo es *SNMPv3*, con grandes mejoras en la seguridad pero también añadiendo mucha más complejidad y trasfondo a este protocolo.

**SMNP** destaca por que permite transmitir comandos de control utilizando agentes mediante *UDP*, especificamente en el puerto *161*.
Estos son los que permiten alterar las configuraciones y opciones en el dispositivo, por parte de un **cliente**.

Por otra parte, permite la utilización de **trampas** o (*traps*) a través del puerto 162, que son paquetes de red que envía el servidor **SNMP** a uno o varios clientes sin que estos lo hayan solicitado previamente.
La idea es que el servidor notifique a o a los clientes **configurados**, que un evento específico acaba de ocurrir.

Finalmente, para que cualquier intercambio de información entre **servidor** y **cliente** ocurra, todos los dispositivos *SNMP* presentes deben tener una ==**dirección** única== que conozcan ambas partes.

### MIB

> ***MIB*** (*Management Information Base*) es un formato de texto desarrollado para almacenar información acerca de dispositivos *SNMP*, pensado para permitir la compatibilidad entre distintos manufacturaciones y combinaciones servidor-cliente de dispositivos *SNMP*.

En resumen, **MIB** es un archivo de texto donde se listan todos los dispositivos *SNMP* bajo una jerarquía de árbol.
Cada dispositivo se representa bajo un **Object Identifier** (*OID*) que, además de la dirección única y el nombre del dispositivo, tambien contiene información acerca del tipo de dispositivo, permisos, descripciones, etc.

Aunque los **MIB** no contienen información detallada, explican donde encontrar información relevante y las características generales del dispositivo.

### SNMPv1

> ***SNMPv1*** es la primera versión de este protocolo y aun se encuentra en uso por parte de redes viejas o pequeñas.

Soporta la mayor parte de características descritas anteriormente como recuperación de información de los dispositivos, configuración remota y *"trampas"*.
Sin embargo, **no** posee ningun mecanismo nativo de **autenticación** lo que significa que cualquiera con acceso a la red puede interactuar con el servicio, recuperando y modificando información de los dispositivos y de la red.

Otra desventaja importante de esta versión es que **no soporta encriptación**, toda la información se envia en texto plano y puede ser facilmente interceptada.

### SNMPv2

> Una versión posterior del protocolo con optimizaciones generales pero manteniendo los mismos problemas que la versión pasada.

Tuvo muchas variantes, destacando `v2c` que sigue activo hasta el presente. La `c` de esta variante hace referencia a **community-based** pues fue la comunidad la que aporto en gran medida al desarrolllo de esta variante.

Actualmente se le ha incorporado el mecanismo de seguridad **Community Strings** (que se ahonda más adelante) para "parchar" apresuradamente la falta de seguridad en esta versión del protocolo, sin embargo, uno de los puntos débiles más importantes es que estas cadenas se transmiten en texto plano por la falta de un mecanismo de cifrado.

### SNMPv3

> En esta nueva versión si se mejoró enormemente muchos mecanismos de seguridad, incorporando un mecanismo propio de **autenticación** mediante usuario y contraseña, además de un nuevo soporte a comunicaciones encriptadas mediante llaves compartidas previamente.

Sin embargo, todas estas nuevas características aumentan proporcionalmente la complejidad del protocolo, con muchas más opciones de configuración presentes en este.

### Community Strings

> Los **Community Strings** pueden pensarse como contraseñas utilizadas para determinar si cierta información solicitada puede ser realmente consultada o no.

Se implementan en ***SNMPv2*** pues muchas organizaciones se mantienen en esta versión del protocolo ya que la transición a ***SNMPv3*** puede resultar costosa y compleja.
Recordemos que aunque útiles, es posible interceptarlas en texto plano pues tienen que enviarse a través de la red mediante una versión del protocolo sin cifrado.

---

## Configuración

> La configuración de este servicio permite definir datos básicos como direcciones IP, puertos, **MIB**, **OIDs**, autenticación, **Community Strings**, etc.
> Esta se realiza en el archivo `/etc/snmp/snmpd.conf` que configura el *daemon* genérico de *SNMP* presente en sistemas *UNIX*.

```bash
cat /etc/snmp/snmpd.conf | grep -v "#" | sed -r '/^\s*$/d'

# sysLocation    Sitting on the Dock of the Bay
# sysContact     Me <me@example.org>
# sysServices    72
# master  agentx
# agentaddress  127.0.0.1,[::1]
# view   systemonly  included   .1.3.6.1.2.1.1
# view   systemonly  included   .1.3.6.1.2.1.25.1
# rocommunity  public default -V systemonly
# rocommunity6 public default -V systemonly
# rouser authPrivUser authpriv -V systemonly
```

### Configuraciones peligrosas

| Configuración                                      | Descripción                                                                                                             |
| -------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `rwuser noauth`                                    | Permite el acceso a usuarios no autenticados en todo el árbol de *OID*s                                                 |
| `rwcommunity <community strings> <dirección IPv4>` | Permite el acceso a los recursos desde los rangos IP especificados siempre que indiquen el *Community String* correcto. |
| `rwcommunity <community strings> <dirección IPv6>` | Lo mismo pero pardirecciones IPv6                                                                                       |

# Enumeración

> Para la enumeración de este servicio podemos utilizar varias herramientas como `snmpwalk`, `onesixtyone` y `braa`.

Particularmente:
- **Snmpwalk** se utiliza para consultar los *OID* presentes y toda su información.
- **Onesixtyone** puede utilizarse para realizar fuerza bruta para descubrir los *Community Strings*.

#### OneSixtyOne

Lo primero suele ser realizar fuerza bruta para determinar el *Community String* del servidor utilizando esta herramienta.

La sintaxis que necesitamos es `onesixtyone -c /ruta/diccionario <IP>`.
Por ejemplo:

```bash
onesixtyone -c /usr/share/seclists/Discovery/SNMP/snmp.txt 10.129.112.237

# 10.129.112.237 [public] Linux NIX02 5.4.0-90-generic #101-Ubuntu SMP Fri Oct 15 20:00:55 UTC 2021 x86_64
```

Esta salida nos indica que el *Community String* descubierto es **public**, de modo que ahora podemos seguir con la enumeración.

#### Snmpwalk

Ya conociendo el *Community String* podemos indicarselo a esta herramienta para que realice una enumeración básica de los dispositivos disponibles en el árbol de información *MIB*.

La sintaxis es `snmpwalk -v2c -c <community string> <IP>`.
- Se indica la bandera `-v2c` para especificar que se trata de *SNMPv2* en su variante `v2c`, pues es ésta la versión que soporta la configuración de *Community Strings*.
- Con la bandera `-c` solo indicamos el *Community String* descubierto

Por ejemplo:

```bash
snmpwalk -v2c -c public 10.129.112.237

# ...
```

Esta herramienta puede imprimir una enorme cantidad de información pero de las líneas más importantes se puede destacar:

- `sysContact`: Indica el correo del administrador del servidor.
- `sysLocation`: Indica un nombre interno asignado al servidor.
- Puede llegar a indicar paquetes de *Software* instalados en el servidor.
- También puede llegar a indicar procesos ejecutandose en el servidor.
- *OID* identificados: Por ejemplo `iso.3.6.1.2.1.1.7.0`

#### Braa

Esta herramienta también permite realizar escaneos masivos de servidores *SNMP* enfocandonos en *OIDs* específicos.

En esta ocasión, la sintaxis es `braa <community string>@<IP>:<OID glob pattern>`.

Si tomamos el *OID* ejemplo, `iso.3.6.1.2.1.1.7.0`, `iso` debe sustituirse por `.1` ya que simplemente es un nombre simbólico.
Además, se puede indicar un patrón de *OID* en lugar de uno específico, por ejemplo, podemos indicar `.1.3.6.*` para consultar todos los dispositivos cuyo *OID* comience con `.1.3.6`.

Entonces el comando se vería así:

```bash
braa public@10.129.14.128:.1.3.6.*

# 10.129.14.128:20ms:.1.3.6.1.2.1.1.1.0:Linux htb 5.11.0-34-generic #36~20.04.1-Ubuntu SMP Fri Aug 27 08:06:32 UTC 2021 x86_64
# 10.129.14.128:20ms:.1.3.6.1.2.1.1.2.0:.1.3.6.1.4.1.8072.3.2.10
# 10.129.14.128:20ms:.1.3.6.1.2.1.1.3.0:548
# 10.129.14.128:20ms:.1.3.6.1.2.1.1.4.0:mrb3n@inlanefreight.htb
# 10.129.14.128:20ms:.1.3.6.1.2.1.1.5.0:htb
# 10.129.14.128:20ms:.1.3.6.1.2.1.1.6.0:US
# 10.129.14.128:20ms:.1.3.6.1.2.1.1.7.0:78
```

# Enlaces

[<- IMAP/POP3](IMAP_POP3.md) | [MySQL ->](MySQL.md)