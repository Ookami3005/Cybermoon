[<- Índice](../../../Pentesting.md)
# Protocolos de Administración Remota Linux

En el gran mundo de las distribuciones *Linux*, existen múltiples maneras y protocolos para administrar un sistema de forma remota.
Estos se encuentran casi en todos los servidores públicos pues proporcionan versatilidad para manipular el sistema sin tener que estar físicamente presente en su ubicación.

Claro, como auditores de seguridad, es importante saber enumerar correctamente estos servicios y entender como funcionan, pues suelen ser una entrada directa a una línea de comandos.

## SSH

> El popular ***SSH*** (*Secure Shell*) permite la comunicación cifrada entre 2 computadoras, salvaguardando la información posiblemente sensible que es transmitida a través de la red.
> Básicamente, permite que el **cliente** se conecte al **servidor** en el puerto **22** y obtenga una **línea de comandos**.

El servidor *SSH* puede configurarse para que únicamente permita conexiones de clientes específicos. Básicamente, se puede definir una *whitelist* de clientes.

Otra ventaja de *SSH* es que es un protocolo compatible con todos los sistemas operativos, ademas de que, por su naturaleza nativa en sistemas *UNIX*, posee implementaciones muy buenas en sistemas *Linux* y *macOS*.

La implemetación más **destacada** por lejos es el conocido **OpenBSD SSH** (o símplemente *OpenSSH*), un *fork* de código abierto del *software* original y comercial de servidor *SSH* publicado por *SSH Communications Security*:

Esto no significa que no podamos encontrar *SSH* en *Windows*, pues existen igual muchas implementaciones de este protocolo para esta familia de sistemas operativos.

Actualmente, se considera que existen 2 versiones de *SSH*: `SSH-1` y `SSH-2`.
Este último se considera un versión más avanzada del protocolo, superandolo en métricas como integridad de la encriptación, velocidad, estabilidad y seguridad general.

Por ejemplo, `SSH-1` es susceptible a ataques **MITM** (*Man In The Middle*), mientras que `SSH-2` no.
Esto es así porque el servidor envía un certificado al cliente cuando se inicia la conexión, con el proposito de verificar que es el servidor correcto.
Entonces se reduce el riesgo de un tercero interponiendose en la comunicación a la primera ocasión que 2 equipos se conectan.
Pero una vez que el cliente conoce el certificado correcto, nadie más puede hacerse pasar por el servidor al que usualmente se conecta pues como los certificados están encriptados, no se pueden imitar.

Volviendo al tema de la administración, como se mencionó antes *SSH* permite el despliegue de una línea de comandos interactiva para el cliente o puede recibir directamente comandos o instrucciones deseadas y ejecutarlas.
Por ejemplo, posee mecanismos básicos de transferencia de archivos, redirección de puertos y ejecución de comandos.

Pero antes, debemos autenticarnos ante el servidor para poder hacer uso de estos servicios.
Actualmente **OpenSSH** soporta 6 métodos de autenticación diferentes:

1. Autenticación mediante **contraseña**
2. Autenticación mediante **llave pública**
3. Autenticación basada en **host** (Sin necesidad de llaves ni contraseñas, únicamente por la confianza que se tienen ambos equipos)
4. Autenticación mediante **teclado**
5. Autenticación mediante **desafio**
6. Autenticación **GSSAPI**

Como los últimos 4 métodos son mecanismos avanzados de autenticación que se salen del alcance de este curso, y dado que ya estamos familiarizados con las autenticaciones por contraseña, ahondaremos únicamente en la autenticación por **llave pública**.

#### Autenticación de llave publica

> Este esquema de autenticación es posible gracias a la criptografía **asimétrica**, donde para cada usuario, se genera una llave pública y una llave privada. La pública se almacena en el servidor mientras que la llave privada la utiliza el cliente para autenticarse ante el servidor.

Esta llave privada debe almacenarse exclusivamente en el equipo **cliente** y mantenerse secreta siempre.
Además, puede protegerse con una *passphrase* que debería ser más larga que una contraseña común. De modo que para poder utilizar esta llave para autenticarse, encima habra que indicar la *passphrase* adecuada.

El mecanismo de autenticación como tal consiste en crear un **desafío criptográfico** utilizando la llave **pública** del cliente, que esta almacenada en el servidor, de modo que solo puede resolverse por aquel que posee la llave **privada** correspondiente.
Una vez autenticado, el servidor sabe que se trata de una conexión legítima y permite el acceso al servicio.

### Configuración

> El archivo de configuración principal del servicio es `sshd_config`, usualmente ubicado en `/etc/ssh`, y posee muy pocos ajustes habilitados por defecto.

```bash
cat /etc/ssh/sshd_config  | grep -v "#" | sed -r '/^\s*$/d'

# Include /etc/ssh/sshd_config.d/*.conf
# AuthorizedKeysFile	.ssh/authorized_keys
# Subsystem	sftp	/usr/lib/ssh/sftp-server
```

Sin embargo, permite muchas opciones más que se pueden habilitar manualmente, por ejemplo la **redirección X11** bien conocida por tener una vulnerabilidad de inyección de comandos en la versión 7.2p1 de *OpenSSH* en 2016.

#### Configuraciones peligrosas

A pesar de que este protocolo se considera uno de los más seguros en la actualidad, existen muchas malconfiguraciones que lo pueden hacer más susceptible a ataques.

Por ejemplo:

| Opción                       | Descripción                                                                                                                                                   |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `PasswordAuthentication yes` | Permite la autenticación por contraseña, si bien no es algo crítico, es más facil atacar esta autenticación por fuerza bruta que una autenticación por llave. |
| `PermitEmptyPasswords yes`   | Permite que los usuarios utilicen contraseñas vacías o nulas.                                                                                                 |
| `PermitRootLogin yes`        | Permite al usuario `root` iniciar sesión de manera remota.                                                                                                    |
| `Protocol 1`                 | Fuerza el uso de `SSH-1`, en lugar de la versión actual.                                                                                                      |
| `X11Forwarding yes`          | Permite la redirección de **X11** para aplicaciones *GUI*.                                                                                                    |
| `AllowTcpForwarding yes`     | Permite la redirección de puertos *TCP*.                                                                                                                      |
| `PermitTunnel`               | Permite el *Tunneling* de la comunicación, básicamente es la redirección de esta.                                                                             |
| `DebianBanner yes`           | Imprime un banner específico al iniciar sesión.                                                                                                               |

### Enumeración

#### ssh-audit

> Una buena herramienta para enumerar este servicio es [`ssh-audit`](https://github.com/jtesta/ssh-audit).
> Este revisa configuraciones esenciales tanto del lado del cliente como del lado del servidor, extrayendo información relevante, por ejemplo, acerca de los **algoritmos de encriptación** utilizados.

Entre otras cosas, esta enumeración de los aspectos criptográficos del servidor, abre la posibilidad de plantear un **ataque criptográfico** posteriormente.

```bash
ssh-audit 10.129.14.132

# # general
# (gen) banner: SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.3
# (gen) software: OpenSSH 8.2p1
# (gen) compatibility: OpenSSH 7.4+, Dropbear SSH 2018.76+
# (gen) compression: enabled (zlib@openssh.com)                                   
# 
# # key exchange algorithms
# (kex) curve25519-sha256                     -- [info] available since OpenSSH 7.4, Dropbear SSH 2018.76                            
# (kex) curve25519-sha256@libssh.org          -- [info] available since OpenSSH 6.5, Dropbear SSH 2013.62
# (kex) ecdh-sha2-nistp256                    -- [fail] using weak elliptic curves
#                                             `- [info] available since OpenSSH 5.7, Dropbear SSH 2013.62
# (kex) ecdh-sha2-nistp384                    -- [fail] using weak elliptic curves
#                                             `- [info] available since OpenSSH 5.7, Dropbear SSH 2013.62
# (kex) ecdh-sha2-nistp521                    -- [fail] using weak elliptic curves
#                                             `- [info] available since OpenSSH 5.7, Dropbear SSH 2013.62
# (kex) diffie-hellman-group-exchange-sha256 (2048-bit) -- [info] available since OpenSSH 4.4
# (kex) diffie-hellman-group16-sha512         -- [info] available since OpenSSH 7.3, Dropbear SSH 2016.73
# (kex) diffie-hellman-group18-sha512         -- [info] available since OpenSSH 7.3
# (kex) diffie-hellman-group14-sha256         -- [info] available since OpenSSH 7.3, Dropbear SSH 2016.73
# 
# # host-key algorithms
# (key) rsa-sha2-512 (3072-bit)               -- [info] available since OpenSSH 7.2
# (key) rsa-sha2-256 (3072-bit)               -- [info] available since OpenSSH 7.2
# (key) ssh-rsa (3072-bit)                    -- [fail] using weak hashing algorithm
#                                             `- [info] available since OpenSSH 2.5.0, Dropbear SSH 0.28
#                                             `- [info] a future deprecation notice has been issued in OpenSSH 8.2: https://www.openssh.com/txt/release-8.2
# (key) ecdsa-sha2-nistp256                   -- [fail] using weak elliptic curves
#                                             `- [warn] using weak random number generator could reveal the key
#                                             `- [info] available since OpenSSH 5.7, Dropbear SSH 2013.62
# (key) ssh-ed25519                           -- [info] available since OpenSSH 6.5
# ...
```

Podemos ver que la herramienta imprime valiosa información como el *banner*, la versión del servicio, metodos de autenticación y demás detalles.

Puede que nos encontremos con distintos y variados *banners* en este servicio, pero por lo general los *banners* predeterminados siguen la misma estructura, primero la versión del protocolo que soportan (*SSH-1* o *SSH-2*) y después la versión del servicio como tal.

Un ejemplo de *banner* podría ser: `SSH-2.0-OpenSSH_8.2p1`.

#### Cambio de método de autenticación

Mediante el modo de depuración, podemos visualizar los **metodos de autenticación** soportados por el servidor, esto agregando la bandera `-v` al comando de la siguiente forma:

```bash
ssh -v cry0l1t3@10.129.14.132

# OpenSSH_8.2p1 Ubuntu-4ubuntu0.3, OpenSSL 1.1.1f  31 Mar 2020
# debug1: Reading configuration data /etc/ssh/ssh_config 
# ...
# debug1: Authentications that can continue: publickey,password,keyboard-interactive
```

Por ejemplo, en este servidor automáticamente se procede con una autenticación por **llave pública**, sin embargo, el servidor también soporta autenticaciones mediante **contraseña** y **teclado**.

Podemos especificar **nuestro** método de autenticación preferido indicando la opción `PreferredAuthentications` con la bandera `-o` así:

```bash
ssh cry0l1t3@10.129.14.132 -o PreferredAuthentications=password

# cryol1t3@10.129.14.132's password: 
```

---
## Rsync

> **Rsync** es una herramienta rápida y eficiente para copiar archivos del servidor de forma **local** y **remota**.

Es una utilidad muy conocida por su **versatilidad**, gracias a su conocido algoritmo de *"transferencia-delta"*.
Este algoritmo permite transmitir muy eficientemente una nueva versión de un archivo ya existente en el destinatario.