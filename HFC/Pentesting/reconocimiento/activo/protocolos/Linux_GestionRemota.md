[<- Índice](../../../Pentesting.md)
# Protocolos de Administración Remota Linux

En el gran mundo de las distribuciones *Linux*, existen múltiples maneras y protocolos para administrar un sistema de forma remota.
Estos se encuentran casi en todos los servidores públicos pues proporcionan versatilidad para manipular el sistema sin tener que estar físicamente presente en su ubicación.

Claro, como auditores de seguridad, es importante saber enumerar correctamente estos servicios y entender como funcionan, pues suelen ser una entrada directa a una línea de comandos.

## SSH

> El popular ***SSH*** (*Secure Shell*) permite la comunicación cifrada entre 2 computadoras, salvaguardando la información posiblemente sensible que es transmitida a través de la red.
> Básicamente, permite que el **cliente** se conecte al **servidor** en el puerto **22** y obtenga una **línea de comandos**.

El servidor *SSH* puede configurarse para que únicamente permita conexiones de clientes específicos. Básicamente, se puede definir una *whitelist* de clientes.

Otra ventaja de *SSH* es que es un protocolo compatible con todos los sistemas operativos, ademas de que, por su naturaleza nativa en sistemas *UNIX*, posee implementaciones muy buenas en sistemas *Linux* y *macOS*.

La implemetación más **destacada** por lejos es el conocido **OpenBSD SSH** (o símplemente *OpenSSH*), un *fork* de código abierto del *software* original y comercial de servidor *SSH* publicado por *SSH Communications Security*:

Esto no significa que no podamos encontrar *SSH* en *Windows*, pues existen igual muchas implementaciones de este protocolo para esta familia de sistemas operativos.

Actualmente, se considera que existen 2 versiones de *SSH*: `SSH-1` y `SSH-2`.
Este último se considera un versión más avanzada del protocolo, superandolo en métricas como integridad de la encriptación, velocidad, estabilidad y seguridad general.

Por ejemplo, `SSH-1` es susceptible a ataques **MITM** (*Man In The Middle*), mientras que `SSH-2` no.
Esto es así porque el servidor envía un certificado al cliente cuando se inicia la conexión, con el proposito de verificar que es el servidor correcto.
Entonces se reduce el riesgo de un tercero interponiendose en la comunicación a la primera ocasión que 2 equipos se conectan.
Pero una vez que el cliente conoce el certificado correcto, nadie más puede hacerse pasar por el servidor al que usualmente se conecta pues como los certificados están encriptados, no se pueden imitar.

Volviendo al tema de la administración, como se mencionó antes *SSH* permite el despliegue de una línea de comandos interactiva para el cliente o puede recibir directamente comandos o instrucciones deseadas y ejecutarlas.
Por ejemplo, posee mecanismos básicos de transferencia de archivos, redirección de puertos y ejecución de comandos.

Pero antes, debemos autenticarnos ante el servidor para poder hacer uso de estos servicios.
Actualmente **OpenSSH** soporta 6 métodos de autenticación diferentes:

1. Autenticación mediante **contraseña**
2. Autenticación mediante **llave pública**
3. Autenticación basada en **host** (Sin necesidad de llaves ni contraseñas, únicamente por la confianza que se tienen ambos equipos)
4. Autenticación mediante **teclado**
5. Autenticación mediante **desafio**
6. Autenticación **GSSAPI**

Como los últimos 4 métodos son mecanismos avanzados de autenticación que se salen del alcance de este curso, y dado que ya estamos familiarizados con las autenticaciones por contraseña, ahondaremos únicamente en la autenticación por **llave pública**.

#### Autenticación de llave publica

> Este esquema de autenticación es posible gracias a la criptografía **asimétrica**, donde para cada usuario, se genera una llave pública y una llave privada. La pública se almacena en el servidor mientras que la llave privada la utiliza el cliente para autenticarse ante el servidor.

Esta llave privada debe almacenarse exclusivamente en el equipo **cliente** y mantenerse secreta siempre.
Además, puede protegerse con una *passphrase* que debería ser más larga que una contraseña común. De modo que para poder utilizar esta llave para autenticarse, encima habra que indicar la *passphrase* adecuada.

El mecanismo de autenticación como tal consiste en crear un **desafío criptográfico** utilizando la llave **pública** del cliente, que esta almacenada en el servidor, de modo que solo puede resolverse por aquel que posee la llave **privada** correspondiente.
Una vez autenticado, el servidor sabe que se trata de una conexión legítima y permite el acceso al servicio.

### Configuración

> El archivo de configuración principal del servicio es `sshd_config`, usualmente ubicado en `/etc/ssh`, y posee muy pocos ajustes habilitados por defecto.

```bash
cat /etc/ssh/sshd_config  | grep -v "#" | sed -r '/^\s*$/d'

# Include /etc/ssh/sshd_config.d/*.conf
# AuthorizedKeysFile	.ssh/authorized_keys
# Subsystem	sftp	/usr/lib/ssh/sftp-server
```

Sin embargo, permite muchas opciones más que se pueden habilitar manualmente, por ejemplo la **redirección X11** bien conocida por tener una vulnerabilidad de inyección de comandos en la versión 7.2p1 de *OpenSSH* en 2016.

#### Configuraciones peligrosas

A pesar de que este protocolo se considera uno de los más seguros en la actualidad, existen muchas malconfiguraciones que lo pueden hacer más susceptible a ataques.

Por ejemplo:

| Opción                       | Descripción                                                                                                                                                   |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `PasswordAuthentication yes` | Permite la autenticación por contraseña, si bien no es algo crítico, es más facil atacar esta autenticación por fuerza bruta que una autenticación por llave. |
| `PermitEmptyPasswords yes`   | Permite que los usuarios utilicen contraseñas vacías o nulas.                                                                                                 |
| `PermitRootLogin yes`        | Permite al usuario `root` iniciar sesión de manera remota.                                                                                                    |
| `Protocol 1`                 | Fuerza el uso de `SSH-1`, en lugar de la versión actual.                                                                                                      |
| `X11Forwarding yes`          | Permite la redirección de **X11** para aplicaciones *GUI*.                                                                                                    |
| `AllowTcpForwarding yes`     | Permite la redirección de puertos *TCP*.                                                                                                                      |
| `PermitTunnel`               | Permite el *Tunneling* de la comunicación, básicamente es la redirección de esta.                                                                             |
| `DebianBanner yes`           | Imprime un banner específico al iniciar sesión.                                                                                                               |

### Enumeración

#### ssh-audit

> Una buena herramienta para enumerar este servicio es [`ssh-audit`](https://github.com/jtesta/ssh-audit).
> Este revisa configuraciones esenciales tanto del lado del cliente como del lado del servidor, extrayendo información relevante, por ejemplo, acerca de los **algoritmos de encriptación** utilizados.

Entre otras cosas, esta enumeración de los aspectos criptográficos del servidor, abre la posibilidad de plantear un **ataque criptográfico** posteriormente.

```bash
ssh-audit 10.129.14.132

# # general
# (gen) banner: SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.3
# (gen) software: OpenSSH 8.2p1
# (gen) compatibility: OpenSSH 7.4+, Dropbear SSH 2018.76+
# (gen) compression: enabled (zlib@openssh.com)                                   
# 
# # key exchange algorithms
# (kex) curve25519-sha256                     -- [info] available since OpenSSH 7.4, Dropbear SSH 2018.76                            
# (kex) curve25519-sha256@libssh.org          -- [info] available since OpenSSH 6.5, Dropbear SSH 2013.62
# (kex) ecdh-sha2-nistp256                    -- [fail] using weak elliptic curves
#                                             `- [info] available since OpenSSH 5.7, Dropbear SSH 2013.62
# (kex) ecdh-sha2-nistp384                    -- [fail] using weak elliptic curves
#                                             `- [info] available since OpenSSH 5.7, Dropbear SSH 2013.62
# (kex) ecdh-sha2-nistp521                    -- [fail] using weak elliptic curves
#                                             `- [info] available since OpenSSH 5.7, Dropbear SSH 2013.62
# (kex) diffie-hellman-group-exchange-sha256 (2048-bit) -- [info] available since OpenSSH 4.4
# (kex) diffie-hellman-group16-sha512         -- [info] available since OpenSSH 7.3, Dropbear SSH 2016.73
# (kex) diffie-hellman-group18-sha512         -- [info] available since OpenSSH 7.3
# (kex) diffie-hellman-group14-sha256         -- [info] available since OpenSSH 7.3, Dropbear SSH 2016.73
# 
# # host-key algorithms
# (key) rsa-sha2-512 (3072-bit)               -- [info] available since OpenSSH 7.2
# (key) rsa-sha2-256 (3072-bit)               -- [info] available since OpenSSH 7.2
# (key) ssh-rsa (3072-bit)                    -- [fail] using weak hashing algorithm
#                                             `- [info] available since OpenSSH 2.5.0, Dropbear SSH 0.28
#                                             `- [info] a future deprecation notice has been issued in OpenSSH 8.2: https://www.openssh.com/txt/release-8.2
# (key) ecdsa-sha2-nistp256                   -- [fail] using weak elliptic curves
#                                             `- [warn] using weak random number generator could reveal the key
#                                             `- [info] available since OpenSSH 5.7, Dropbear SSH 2013.62
# (key) ssh-ed25519                           -- [info] available since OpenSSH 6.5
# ...
```

Podemos ver que la herramienta imprime valiosa información como el *banner*, la versión del servicio, metodos de autenticación y demás detalles.

Puede que nos encontremos con distintos y variados *banners* en este servicio, pero por lo general los *banners* predeterminados siguen la misma estructura, primero la versión del protocolo que soportan (*SSH-1* o *SSH-2*) y después la versión del servicio como tal.

Un ejemplo de *banner* podría ser: `SSH-2.0-OpenSSH_8.2p1`.

#### Cambio de método de autenticación

Mediante el modo de depuración, podemos visualizar los **metodos de autenticación** soportados por el servidor, esto agregando la bandera `-v` al comando de la siguiente forma:

```bash
ssh -v cry0l1t3@10.129.14.132

# OpenSSH_8.2p1 Ubuntu-4ubuntu0.3, OpenSSL 1.1.1f  31 Mar 2020
# debug1: Reading configuration data /etc/ssh/ssh_config 
# ...
# debug1: Authentications that can continue: publickey,password,keyboard-interactive
```

Por ejemplo, en este servidor automáticamente se procede con una autenticación por **llave pública**, sin embargo, el servidor también soporta autenticaciones mediante **contraseña** y **teclado**.

Podemos especificar **nuestro** método de autenticación preferido indicando la opción `PreferredAuthentications` con la bandera `-o` así:

```bash
ssh cry0l1t3@10.129.14.132 -o PreferredAuthentications=password

# cryol1t3@10.129.14.132's password: 
```

---
## Rsync

> **Rsync** es una herramienta rápida y eficiente para copiar archivos del servidor de forma **local** y **remota**, comunmente utilizada para generar respaldos y servidores *"espejo"*.

Es una utilidad muy conocida por su **versatilidad**, gracias a su conocido algoritmo de *"transferencia-delta"*.
Este algoritmo permite transmitir muy eficientemente una nueva versión de un archivo ya existente en el destinatario, pues únicamente envia las diferencias entr ambas versiones del archivo, de modo que se actualice el archivo obsoleto del destinatario.

Para identificar los archivos que necesitan ser **transferidos**, constantemente monitorea archivos para identificar variaciones en su tamaño o en su último acceso.

Por defecto, este servicio utiliza el puerto **873** y puede ser configurado para aprovechar una conexión *SSH* para transferir archivos de forma segura.

Muchas veces, es posible listar el contenido de carpetas compartidas, formalmente denominadas **módulos Rsync**, que esten presentes en el servicio e incluso recuperar archivos sin siquiera autenticarnos, aunque en otras ocasiones si será necesario conocer de antemano las credenciales de algun usuario para realizar estas operaciones.

### Enumeración

> Esta [guía](https://book.hacktricks.wiki/en/network-services-pentesting/873-pentesting-rsync.html) cubre varias técnicas en las que podemos enumerar carpetas y demás información importante del servicio, unas de las más importantes son:

#### Nmap

La herramienta **Nmap** permite realizar un primer acercamiento al objetivo, identificando si esta presente e incluso enumerando carpetas compartidas presentes.

###### Identificando el servicio

```bash
sudo nmap -sV -p 873 127.0.0.1

# Starting Nmap 7.92 ( https://nmap.org ) at 2022-09-19 09:31 EDT
# Nmap scan report for localhost (127.0.0.1)
# Host is up (0.0058s latency).
# 
# PORT    STATE SERVICE VERSION
# 873/tcp open  rsync   (protocol version 31)
# 
# Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done: 1 IP address (1 host up) scanned in 1.13 seconds
```

###### Listando carpetas compartidas con Nmap

```bash
nmap --script "rsync-list-modules" -p 873 127.0.0.1
```

#### Enumeración de carpetas accesibles

Similar a **Nmap**, podemos identificar **carpetas compartidas accesibles** de forma manual, utilizando `netcat` o `ncat` para comunicarnos directamente con el servicio e indicando el comando `#list`.

Esto se vería de la siguiente forma:

```bash
nc -nv 127.0.0.1 873

# (UNKNOWN) [127.0.0.1] 873 (rsync) open
# @RSYNCD: 31.0
# @RSYNCD: 31.0
# #list
# dev            	Dev Tools
# @RSYNCD: EXIT
```

En este ejemplo, podemos ver que se nos indica la existencia de una carpeta `dev`.

#### Listando los archivos de una carpeta compartida

Ya identificado una carpeta compartida, `dev` en el ejemplo anterior, y si tenemos los suficientes permisos, podemos listar los archivos en esta con apoyo de la utilidad `rsync` e incluso descargarlos a nuestra máquina.

Para listar los archivos, sin descargarlos, podemos utilizar el siguiente comando:

```bash
rsync -av --list-only rsync://127.0.0.1/dev

# receiving incremental file list
# drwxr-xr-x             48 2022/09/19 09:43:10 .
# -rw-r--r--              0 2022/09/19 09:34:50 build.sh
# -rw-r--r--              0 2022/09/19 09:36:02 secrets.yaml
# drwx------             54 2022/09/19 09:43:10 .ssh
#
# sent 25 bytes  received 221 bytes  492.00 bytes/sec
# total size is 0  speedup is 0.00
```

- La bandera `-a` indica que se utilice el modo archivo, que realiza una copia fiel y exacta de los archivos del servidor, conservando permisos, fechas y propietarios
- La bandera `-v` activa el modo verboso
- La bandera `--list-only` indica que se impriman en pantalla los archivos identificados, sin descargarlos
- La *URL* indica el protocolo, servidor y carpeta compartida

Después, para descargar los archivos a cualquier directorio, por ejemplo a `rsyn_shared`, podemos utilizar los siguientes comandos, ya sea que se permita descargarlos sin autenticarnos o no, respectivamente.

```bash
rsync -av rsync://192.168.0.123:873/shared_name ./rsyn_shared

rsync -av rsync://username@192.168.0.123:873/shared_name ./rsyn_shared
```

En caso de que deseemos utilizar este servicio encima de *SSH*, debemos especificar la bandera `-e ssh` en caso de que el servicio *SSH* se encuentre en el puerto estándar o `-e "ssh -p2222"` en caso de que debamos indicar un puerto distinto, como 2222.

## R-Services

> Los **R-Services** son todo un conjunto de servicios que permiten el acceso y la ejecución de comandos remota en sistemas *UNIX* a través de la red por medio de protocolos *TCP/IP*.

Inicialmente desarrollados por **CSRG** (*Computer Systems Research Group*) en la universidad de California, *Berkeley*.
Estos **servicios R** sentaron el estándar para accesos remotos entre sistemas operativos **UNIX** hasta que fueron remplazados por **SSH** debido a varias debilidades en su implementación.

Similar a `telnet`, los **R-Services** transmiten información entre el cliente y servidor en **texto plano**, es decir, sin **encriptación**, lo que hace viables ataques tipo **MITM** (*Man in the Middle*) para interceptar tráfico de red y obtener contraseñas, información sensible y demás.

Estos **servicios R** suelen ubicarse en los puertos **512**, **513** y **514** y solo son accesible mediante un conjunto de utilidades denominados **r-commands**.
Aunque actualmente caen cada vez más en desuso, aún podríamos encontrarlos en sistemas operativos **comerciales** como *Solaris*, *HP-UX*, *AIX* y demás.

Las utilidades que conforman los **r-commands** son:

- `rcp` (*remote copy*)
- `rexec` (*remote execution*)
- `rlogin` (*remote login*)
- `rsh`(*remote shell*)
- `rstat`
- `ruptime`
- `rwho` (*remote who*)

Cada comando se encarga totalmente en cubrir una funcionalidad específica, sin embargo, solo nos enfocaremos en las utilidades más útiles para enumerar el servicio.

| Comando  | Puerto | Protocolo de Transporte | Descripción                                                                                                                                                                                                                                                                    |
| -------- | ------ | ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `rcp`    | 514    | *TCP*                   | Copia un archivo o directorio del sistema local al remoto o viceversa.<br>Tambien permite realizar la copia entre distintos sistemas remotos y se comporta igual al comando *UNIX* `cp`.<br>                                                                                   |
| `rsh`    | 514    | *TCP*                   | Abre una línea de comandos de la máquina remota sin ningún mecanismo de autenticación.<br>Se basa en relaciones de confianza con dipositivos especificos que se configuran en `/etc/hosts.equiv` o en `.rhosts`.                                                               |
| `rexec`  | 512    | *TCP*                   | Permite a un usuario ejecutar comandos de terminal en la máquina remota.<br>Este si requiere autenticación mediante usuario y contraseña aunque pueden configurarse relaciones de confianza para obviar este mecanismo en los archivos mencionados anteriormente.              |
| `rlogin` | 513    | *TCP*                   | Permite a un usuario iniciar sesión en el sistema remoto y obtener una línea de comandos, funciona de manera similar a *telnet* pero únicamente permite conexiones entre dispositivos *UNIX*.<br>De nuevo, pueden configurarse relaciones de confianza en los mismos archivos. |

### Configuración

Como se mencionó anteriormente, en el archivo `/etc/hosts.equiv` se almacena una lista de dispositivos de confianza a los que se les otorga acceso inmediato a muchas funcionalidades de los **r-commands**.
También, es necesario especificar un usuario del dispositivo al que se le garantizan estos privilegios de modo que el archivo se ve de la siguiente forma:

```bash
cat /etc/hosts.equiv

# # <hostname> <local username>
# pwnbox cry0l1t3
```

El archivo `hosts.equiv` es el archivo de configuración por defecto de los **R-Services**, sin embargo se prioriza la configuración del archivo `.rhosts`, solo si este se encuentra presente en el directorio hogar del usuario que ofrece los **servicios R**. 

La sintaxis es muy similar a `hosts.equiv`, solo que se invierte el orden del usuario y *host* y permite el uso de comodines `+` para indicar tanto cualquier usuario como cualquier *host*.

Por ejemplo:

```bash
cat ~/.rhosts

# htb-student     10.0.17.5
# +               10.0.17.10
# +               +
```

#### Configuraciones peligrosas

> Una de las principales razones por las que los **R-Services** cayeron en desuso fue por sus problemas inherentes en el diseño de su control de acceso y autenticación.

El hecho de que permita **relaciones de confianza** daba lugar a potenciales malconfiguraciones que podrían ser aprovechadas para omitir la autenticación en el uso de estos servicios.

### Enumeración

#### Nmap

Como ya es costumbre, **Nmap** permite identificar el estado de los servicios y si son accesibles para nuestro dispositivo:

```bash
sudo nmap -sV -p 512,513,514 10.0.17.2

# Starting Nmap 7.80 ( https://nmap.org ) at 2022-12-02 15:02 EST
# Nmap scan report for 10.0.17.2
# Host is up (0.11s latency).
# 
# PORT    STATE SERVICE    VERSION
# 512/tcp open  exec?
# 513/tcp open  login?
# 514/tcp open  tcpwrapped
# 
# Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done: 1 IP address (1 host up) scanned in 145.54 seconds
```

#### Accediendo mediante `rlogin`

Si la mala configuración del servicio lo permite, podemos iniciar sesión sin credenciales mediate el **r-command** `rlogin`.
Por ejemplo, sea el `.rhosts` de la sección anterior, podríamos ejecutar el siguiente comando para iniciar sesión en el dispositivo como el usuario `ookami`:

```bash
rlogin 10.0.17.2 -l ookami

# Last login: Fri Dec  2 16:11:21 from localhost
#
# [ookami@localhost ~]$
```

#### Listando usuarios autenticados con `rwho`

Si en la red estan correctamente configurados los **R-Services**, podemos utilizar el **r-command** `rwho` para listar usuarios autenticados usando algun **R-Service** en dicho momento.

Esto solo funciona si los dispositivos han sido configurados correctamente para compartir su información con los demás dispositivos en la red, mediante el uso del *daemon* `rwhod` y el protocolo *UDP* para compartir de forma rápida la información.

Se realiza ejecutando el comando en tu máquina local, siempre que estes conectado a la misma red que los demás dispositivos:

```bash
rwho

# root     web01:pts/0 Dec  2 21:34
# htb-student     workstn01:tty1  Dec  2 19:57  2:25
```

Esta es una manera sencilla de identificar potenciales *usernames* en los dispositivos, de los que podríamos disponer más tarde.

#### Listando usuarios autenticados con `rusers`

Para obtener información complementaria a `rwho`, siempre podemos disponer de la utilidad `rsusers`.
Este ofrece información más detallada de los usuario autenticados con sesiones activas en los **servicios R**, como *usuario*, *host*, *TTY* y hora y fecha del inicio de sesión.

```bash
rusers -al 10.0.17.5

# htb-student     10.0.17.5:console          Dec 2 19:57     2:25
```

La bandera `-a` indica que se imprima la respuesta de todos los dispositivos, incluso si no hay usuarios activos mientras que la bandera `-l` indica que se imprima información detallada de los usuarios.

---
# Enlaces

[<- IPMI](IPMI.md) | [Administración remota Windows ->](Windows_GestionRemota.md)