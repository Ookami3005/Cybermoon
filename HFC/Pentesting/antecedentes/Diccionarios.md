[<- Índice](../Pentesting.md)
# Diccionarios

Un *"diccionario"* o *"wordlist"* en el contexto de ==*ataques de fuerza bruta*==, no es más que una lista de palabras que **pensamos** que podrían ser la contraseña, usuario o incluso recurso **deseado** de algun servicio, formulario de inicio de sesión, ordenador, o de cualquier sistema que buscamos comprometer.

> ¡La eficacia de un **ataque de fuerza bruta** reside enormemente en el diccionario utilizado!

Aunque existen muchos diccionarios conocidos y estandarizados de contraseñas, usuarios, páginas web y muchas cosas más, en esta nota pretendo recopilar herramientas que nos permiten buscar o generar diccionarios ==más específicos o personalizados==.

### `wordlistctl`

> [*Wordlistctl*](https://github.com/BlackArch/wordlistctl) es un *Script* que recopila diccionarios de múltiples páginas *web* y te permite buscar, filtrar y descargarlos. Será nuestra ***base*** para la busqueda de diccionarios existentes.

Por defecto, `wordlistctl` instala los diccionarios en `/usr/share/wordlists`, por lo que necesitara permisos de administrador (`sudo`) cuando deseemos instalarlos, pero no necesariamente para buscarlos.

`wordlistctl` posee más de 6000 diccionarios disponibles que podemos listar con `wordlistctl list`, aunque algunos podrían ya no estar disponibles según el estado de la página de la que se ofrecen.

#### Uso

\> Supongamos que deseamos descargar un diccionario de nombres estadounidenses.

Lo primero que debemos hacer es buscar una palabra clave (por ejemplo `names`, `usa`, `malenames`) con el comando:

```bash
wordlistctl search malenames

# 0 > femalenames-usa-top1000 (6.94 Kb)
# 1 > malenames-usa-top1000 (6.68 Kb)
# 2 > maleNames-password (22.54 Kb)
# 3 > top_1000_usa_femalenames_english (6.78 Kb)
```

Si deseamos ==instalar una opción en específico==, por ejemplo `malenames-usa-top1000` de la posición `1`, se utiliza el comando:

```bash
sudo wordlistctl search malenames -f 1 -d
```

Con la bandera `-f` se indica la opción que queremos instalar y la opción `-d` indica que se descomprima. Aunque está ultima opción unicamente es necesaria cuando se trata de un diccionario comprimido, recomendo ampliamente indicarla siempre, por cuestiones de comodidad.

Por el contrario, si deseamos ==instalar todas las opciones devueltas en la busqueda==, utilizamos el comando `fetch`:

```bash
sudo wordlistctl fetch malenames -d
```

### `cewl`

> [*Cewl*](https://github.com/digininja/CeWL) es una herramienta que permite generar un diccionario con palabras relevantes de una **página web** mediante la realización de *Spidering* a través del sitio web.

#### Uso

El comando tradicional de `cewl` es:

```bash
cewl -d [prof] -w output.txt https://example.org
```

- `[prof]` es un ***número no negativo*** que indica la profundidad de *Spidering*, es decir, que tanto *"nos adentraremos"* (cuantas veces seguimos *links* **consecutivamente**) en la página. Si no deseamos seguir *links* y generarlo solo con la página inicial, debemos indicar un `0` pero usualmente se pone un número como `2`o `3`.
- `output.txt` es el archivo donde se almacenará el diccionario generado.
- `https://example.org` es el sitio del cual nos basaremos para generar el diccionario

### `pnwgen`

> [*Pnwgen*](https://github.com/toxydose/pnwgen) es una herramienta que permite generar todos los números de telefono posibles a partir de una extensión válida de telefono.

Su uso es muy simple:

```bash
python3 pnwgen.py [prefijo] [sufijo] [longitud]
```

Por ejemplo para generar una lista de todos los números de telefono con el prefijo `+1721`, sin sufijo y de longitud `7`:

```bash
python3 pnwgen.py +1721 '' 7
```

### `lyricpass`

> Antes de pasar a la última herramienta, quería hacer una mención honorífica (aunque probablemente inútil) a [*Lyricpass*](https://github.com/initstring/lyricpass), aunque su uso es muy particular me pareció gracioso.

Podemos generar un diccionario basado en las letras de las canciones más populares de algún artista con el siguiente comando.

```
lyricpass -a [artista]
```

### `ttpassgen`

> [*TTPassGen*](https://github.com/tp7309/TTPassGen) es un generador de diccionarios simples altamente versátil, rápido y personalizable. Es perfecto para generar diccionarios con patrones *"sencillos"* personalizados o incluso para combinar diccionarios de maneras específicas.

Permite una ==especificación similar a expresiones regulares== para los patrones, lo que nos brinda un control espectacular sobre las definiciones de estos.

Por esto mismo será la herramienta que detallaré con mayor medida en esta nota

#### Uso básico

El uso más basico de `ttpassgen` consiste del siguiente comando:

```bash
ttpassgen -r [regla] output.txt
```

##### Reglas

Aqui reside el poder de `ttpassgen` por lo que intentaré dar la explicación más completa y concisa que pueda.

###### Carácteres

Cualquier caracter o conjunto de caracteres que deseemos especificar o seleccionar, debe estar encerrado entre corchetes (`[]`)

La herramienta reconoce las siguientes cadenas como equivalencias de un *"arreglo"* de varios caracteres, para simplificar la sintaxis de las reglas:

```
?l = abcdefghijklmnopqrstuvwxyz

?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ

?d = 0123456789

?s = !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~

?a = ?l?u?d?s

?q = ]
```

Por ejemplo `[?d?l]` representa o selecciona ***un*** caracter que sea número o letra minúscula.

###### Repeticiones

> Podemos indicar cuantas veces queremos que se repita un caracter de un conjunto seleccionado de varias maneras:

`[?d]` -> Exactamente una vez

`[?d]?` -> 0 o 1 repetición.

`[?d]{m:n:r}` -> `m` es el numero mínimo de repeticiones, `n` es el máximo de repeticiones y `r` el modo de repetición \[`?` o `*`]. Posee las siguientes variaciones:
- `[?d]{m:n}`
- `[?d]{n}`
- `[?d]{n:r}`

Ahondando en esta última regla:
- El modo de repetición `?` indica que los caracteres del conjunto seleccionado aparecen 0 o 1 vez en la cadena generada, es decir, no pueden repetirse.
- El modo de repetición `*` si permite la repetición de caracteres sin restricción.

Algunos ***ejemplos*** para entenderlo mejor son:

- `[12]`: Genera `1` y `2`
- `[1][2]?`: Genera `1` y `12` 
- `[12]{2:2:?}` o `[12]{2:?}` o `[12]{2}`: Genera `12` y `21`
- `[12]{2:2:*}` o `[12]{2:*}`: Genera `11`, `12`, `21` y `22`

###### Cadenas

> Podemos agregar cadenas o incluso arreglos de cadenas a la regla:

Para **una sola cadena**, simplemente la agregamos en la regla sin ninguna sintaxis especial (`cadena[23]{2}`)

Para **un arreglo de cadenas** se sigue una sintaxis y una idea muy similar a los caracteres: `$(string1,string2){m:n:r}`

Por ejemplo:
- `$(nombre1,nombre2,nombre3)apellido`: Genera `nombre1apellido`, `nombre2apellido` y `nombre3apellido`.

#### Utilizando diccionarios

> Para utilizar diccionarios en las reglas, primero debemos indicar los archivos separados por comas (`,`) mediante la bandera `--dictlist`:

```bash
ttpassgen --dictlist "dict1.txt,dict2.txt" -r [regla] output.txt
```

Ahora, en la regla, podemos utilizar las palabras de los diccionarios como cadenas `$indice` según su posición en la bandera empezando desde el `0`. Por ejemplo, `$0` hace referencia a las palabras de `dict1.txt` y `$1` a las de `dict2.txt`

\> ¡Esto nos permite crear todas las combinaciones posibles de la manera que queramos de **todas** las palabras de 2 diccionarios!

#### Ejemplos finales

1. ***Pin*** Este comando genera todas las combinaciones de contraseñas *pin* de 4 dígitos: 

```bash
ttpassgen -r '[?d]{4:*}' pin4.txt
```

2. ***Palabras cortas de letras minúsculas*** Este comando genera todas las combinaciones de minúsculas de 1 a 3 letras:

```bash
ttpassgen -r '[?l]{1:3:*}' abc.txt
```

3. ***Combinación de diccionarios*** Este comando fusiona los diccionarios de los ejemplos anteriores con un guión en medio:

```bash
ttpassgen --dictlist 'abc.txt,pin4.txt' -r '$0[-]$1' fusion.txt
```

4. ***Emulando pnwgen***

```bash
ttpassgen -r '+1721[?d]{7:*}' phones.txt
```

# Enlaces

[<- Esteganografía](Esteganografia.md) | [Crackeo de hashes básico ->](HashCrackingBasico.md)