[<- Índice](../Pentesting.md)
# Crackeo de hashes más avanzado

> En esta sección, pretendo ahondar un poco en las ***mutaciones*** de contraseñas además de algunas ***configuraciones*** útiles de `john`.

Cabe recalcar que las ==mutaciones== **suelen** usarse cuando tenemos una noción o algunas pistas sobre la contraseña que deseamos obtener, de modo que podamos *optimizar* nuestro ataque hacia esta.

## Más *John*

> Es importante mencionar que `john` posee 3 modos actualmente:

- ***Simple*** (*Single*)
- ***Incremental***
- ***Diccionario*** (*Wordlist*)

### Simple

> El modo ***simple*** de `john` consiste en utilizar información básica acerca del dueño como posibles candidatos bajo un gran conjunto de ==reglas de mutación== (que describiré en un momento). 

```bash
john --single [archivo]
```

**¿De donde saca esta información?** `john` utiliza el nombre completo, nombre de usuario, nombre de la carpeta hogar y más datos que pueda encontrar en `/etc/passwd` sobre el propietario del *hash*.

Para esto, `john` incluye la utilidad `unshadow` que combina el archivo que contiene la información del usuario o usuarios (en un formato como el de `/etc/passwd`) con el archivo de contraseña(s) (en formato similar a `/etc/shadow`):

```bash
unshadow [archivo_usuario] [archivo_hash] > unshadow
```

Aunque solo puede hacerlo si posees ***acceso*** o una ***copia*** del archivo de contraseñas, claramente, pues lo ideal es extraer de ahi la línea que corresponda al usuario que deseas crackear.

Por todo lo anterior, es muy importante recalcar que este modo es muy específico para crackear ==hashes de inicio de sesión *UNIX*== donde tenemos acceso al entorno, pues depende de la información que pueda otorgarle el archivo de usuarios por lo que no será muy útil para cualquier otra circunstancia.

### Incremental

> El modo incremental es el máximo exponente de la fuerza bruta, consiste en intentar todas las posibles combinaciones de caracteres sin ningún criterio, simplemente todas.

Esto, por supuesto, debería de ser nuestra última opción pues es abismalmente complejo, satura todo el procesamiento del equipo y sería el más lento en obtener la contraseña.

Posee varias variantes que indican todos los caractéres a probar como:

- ***ASCII*** (Todos los caractéres *ASCII*)
- ***Alnum*** (Todos los caractéres alfanuméricos)
- ***Alpha*** (Todas las letras mayúsculas o minúsculas)
- ***UpperNum/LowerNum*** (Letras mayúsculas/minusculas y digitos)
- ***Digits*** (Unicamente dígitos)

Estas se indican con la bandera `--incremental`, por ejemplo:

```bash
john --incremental=ASCII [archivo]
john --incremental=Alnum [archivo]
```

### Diccionario

> El modo más utilizado y por lejos de `john`, comprueba todos las palabras de una lista como posibles candidatos de la contraseña.

Prácticamente ya hemos sido introducidos a este modo en la [nota anterior](HashCrackingBasico.md), ya que es el uso básico de la herramienta. Entonces voy a ahondar principalmente en las ***reglas de mutación***, pero me gustaría compartir una configuración útil que encontré.

En el archivo de configuración `john.conf`, ubicado en la carpeta principal de `john` (probablemente en `/usr/share/john/`, en `/etc/john` o donde lo hayas clonado) podemos específicar un diccionario por defecto:

```ini
#---------------------------------------------------------
#john.conf
#---------------------------------------------------------

Wordlist=/usr/share/wordlists/rockyou.txt

```

Esto se hace modificando el valor de `Wordlist` con la ruta del diccionario que deseemos. En este ejemplo, el tan utilizado `rockyou`, de manera que no tengamos que especificar la ruta completa del diccionario en cada uso.

#### *Reglas de Mutación* (Mangling Rules)

> Las ***reglas de mutación*** de `john` son reglas que indican las modificaciones que deseamos aplciar sobre los candidatos de un diccionario.

Muchas veces, poseemos pistas específicas sobre la contraseña (o simplemente decidimos probar suerte) de modo que un diccionario común no es suficientemente específico.

Claro, podriamos utilizar herramientas para generar diccionarios más adecuados como vimos antes, pero esto muchas veces se vuelve dificil ademas de ocupar tiempo, espacio y procesamiento para un diccionario que probablemente solo utilicemos una vez.

Entonces la solución, es aplicar un conjunto de reglas de modificación a cada palabra del diccionario *"en tiempo de ejecución"* sin consumir todo el espacio de un diccionario completo.

Para definir estas reglas, recomiendo crear el archivo de configuración `john-local.conf`, pues `john` lo importa automáticamente. La sintaxis es la siguiente:

```ini
#---------------------------------------------------------
#john-local.conf
#---------------------------------------------------------

[List.Rules:Nombre]
# Regla
# Regla

[List.Rules:Nombre2]
# Regla
# Regla
```

Como podemos ver, se indica la sección `List.Rules` seguida de el nombre que identifica a la regla, debajo irán todas las reglas que creemos.

Toda la información a continuación, esta basada en la documentación oficial de `john`, aqui solo pondré las opciones más importantes pero si quieres una explicación más detallada sobre las reglas, no dudes en leerla en este [enlace](https://www.openwall.com/john/doc/RULES.shtml).

##### Constantes numéricas

> Este tipo de constantes ***hacen referencia a la posición en una palabra*** y ***no deben confundirse con  caracteres agregados*** porque ==representan más bien **números**== para ser usados en otras opciones.

- `0`...`9`: Representan las posiciones 0 (antes de la primera letra) a la novena letra.
- `A`...`Z`: Representan de la posición 10 hasta la posicón 35.
- `z`: *"Posición infinita"*, es decir, final de la palabra, despues de la última letra.

##### Clases de caracteres

> Representan un conjunto de caractéres de modo que simplifiquen la notación, y también estan pensados para utilizarse en otras opciones.

- `?a`: Cualesquiera letras en mayúscula o minúscula
- `?v`: Representa a las vocales en minúscula y mayúscula.
- `?c`: Consonantes en mayúscula y minúscula
- `?l`: Letras en minúscula
- `?u`: Letras en mayúscula
- `?d`: Dígitos
- `?x`: Todas las letras (mayusculas y minúsculas) y dígitos
- `?p`: Puntuaciones (`.,:;'?!` y *\`*)
- `?s`: Símbolos especiales (`$%&*+#@$` y más)
- `?z`: Cualquier caracter

Tambien, podemos definir ***complementos*** u ***opuestos*** de clases, indicando la letra en mayúscula, por ejemplo `?D` representa todo menos números, `?S` todo menos símbolos especiales.

##### Comandos simples

> Estas opciones ahora si ***modifican*** las palabras de manera sencilla, por eso se denomina comandos.

- `l`: Vuelve minúscula todas las letras de la palabra
- `u`: Vuelve mayúscula todas las letras de la palabra
- `c`: *"Capitaliza"* la palabra, es decir, la primera letra en mayúscula y las demás en minúscula.
- `C`: Lo opuesto a capitalizar, vuelve minúscula la primera letra y el resto en mayúscula.
- `t`: Invierte mayúsculas y minúsculas
- `TN`: Invierte la mayúscula o minúscula del caracter en la posición `N` (donde `N` es una constante numérica vista anteriormente)
- `r`: Invierte la palabra (`Fred` -> `derF`)
- `d`: Duplica la palabra (`Fred` -> `FredFred`), si es usada más de una vez, triplica (`dd`), cuatriplica (`ddd`), etc.

##### Comandos de Inserción

> Comandos que insertan caractéres o cadenas.

- `$X`: Agrega ***al final*** el caracter `X` (cualquiera)
- `^X`: Agrega ***al inicio*** el caracter `X`
- `iNX`: Inserta el caracter `X` en la posición `N` y recorre el resto de la palabra ahcia la derecha
- `oNX`: Remplaza el caracter en la posición `N` con `X` sin recorrer la palabra
- `sXY`: Remplaza todos los caracteres `X` con el caracter `Y` en la palabra
- `AN"cadena"`: Inserta la cadena dada (`"cadena"`) en la posición `N`, por ejemplo para prefijar una cadena "pre" se utiliza `A0"pre"` y para sufijar "lo" `Az"lo"` aunque claro, puede introducirse una cadena en cualquier posición de la palabra.

##### Comandos de Borrado

> Comandos que eliminan caracteres y extracción de cadenas

- `\[`: Elimina el primer caracter
- `\]`: Elimina el último caracter
- `DN`: Elimina el caracter en la posición `N`
- `@X`: Elimina todos los caracteres `X` de la palabra
- `zNM`: Extrae la subcadena entre las posiciones `N` y `M` y descarta el resto.

##### Comandos de clases de caractéres

> Comandos de remplazo y eliminación comtaibles con las clases de caractéres vistas anteriormente.

- `s?CY`: Remplaza todos los caracteres de la clase `?C` (`?l`, `?d`, la que sea) con el caracter `Y`.
- `@?C`: Elimina todos los caractéres de la clase `?C` de la palabra.

##### Preprocesador de reglas

> Finalmente, las reglas en `john` cuentan con su propio ***preprocesador*** que simplifica la sintaxis de las reglas haciendonos la vida más fácil.

Por ejemplo, supongamos que queremos probar con un digito del 0 al 9 al final de la palabra. Esto se vería así, bajo nuestra sintaxis hasta ahora:

```ini
[List.Rules:Append0to9]
$0
$1
$1
...
$9
```

Esto, por supesto, no fue eficiente y si quisieramos agregar 2 caarácteres, ¿Tendríamos que escribir 100 reglas?

La respuesta es ***No***, pues el ***preprocesador*** esta aquí para salvarnos de tareas absurdas como esta. Basta con definiruna lista o un rango entre corchetes (de símbolos, letras o números) para que este se encargue de *"expandir"* las reglas que queremos.

Por ejemplo:

```ini
[List.Rules:Append0to9]
$[0-9]
# Equivale a 10 reglas

[List.Rules:AppendAtoMAndMore]
$[A-M#?!%]
# Equivale a 17 reglas

[List.Rules.Append0to9Twice]
$[0-9]$[0-9]
# Equivale a 100 reglas
```

De este modo, nosotros podemos escribir una sintaxis comprimida de las reglas que deseamos, similar a la sintaxis de expresiones regulares, y dejar que el ***preprocesador*** se encargue de expandir estas reglas antes de pasarselas a `john` al momento de crackear.

#### Ejemplos finales

> Ahora que sabemos lo básico de las reglas, podemos brindar unos ejemplos de su uso con las mutaciones más famosas:

Cabe recalcar que basta con escribir las reglas que queramos en la ***misma línea*** para que se ==apliquen a la vez== en el mismo intento o en ***líneas distintas*** para que se ==apliquen por separado en intentos distintos==.

##### Freak

Las mutaciones **Freak** son aquellas donde las letras (comúnmente vocales) son remplazadas por números o símbolos parecidos a ellas.

```ini
[List.Rules:Freak]
sa@ se3 si1 so0
```

##### Border

Las comunes mutaciones **Border** son aquellas donde se agregan números y símbolos especiales al principo o final (usualmente al final) de una palabra.

Es de las más comunes, pues es la propuesta más común a sitios que **exigen** el uso de caracteres especiales y números.

```ini
[List.Rules:Border]
$[0-9!#$%&+*/-]
$[0-9!#$%&+*/-]$[0-9!#$%&+*/-]
$[0-9!#$%&+*/-]$[0-9!#$%&+*/-]$[0-9!#$%&+*/-]
$[0-9!#$%&+*/-]$[0-9!#$%&+*/-]$[0-9!#$%&+*/-]$[0-9!#$%&+*/-]
```

##### Otros

Por ejemplo algunos sufijos con las palabras en minúsculas:

```ini
[List.Rules:Suffix]
l Az"luna"
l Az"sol"
l Az"tierra"
```

Y este para eliminar todas las mayúsculas y remplazar todas las vocales por 1, duplicar e invertir.

```
[List.Rules:ReglaRara]
@?u s?v1 d r
```

# Enlaces

[<- Crackeo de Hashes básico](HashCrackingBasico.md) |