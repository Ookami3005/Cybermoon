[<- Índice](../Pentesting.md)
# Decodificaciones comunes

Los datos codificados en varios formatos son comúnes de ver tanto en *CTFs* como en escenarios de la vida real.

Por tanto hablaré muy ligeramente de algunas de las codifcaciones importantes que he utilizado mientras estudio sobre esto:

### *Base64* y *Base32*

> Para ambas codificaciones existen, respectivamente, los comandos `base64` y `base32` que decodifican (y codifican) archivos completos pero puedes redirigir a traves de un *pipe* (`|`) un `echo -n` con el mensaje que deseas decodificar.

Este *pipe* aplica para **todos los comandos que reciban nombres de archivos**.

Además se le especifíca la bandera `-n` a `echo` para que no anexe un **salto de línea al final de los textos**.

```bash
# Mensaje en base64
echo -n "SG9sYQ==" | base64 -d # Bandera para decodificar
# > Hola

# Mensaje en base 32
echo -n "JBXWYYI=" | base32 -d
# > Hola
```

##### ¿Y cómo distingo *base64* y *base32*?

*Base32* unicamente posee letras mayúsculas, además de que puede poseer más simbolos `=` que *Base64* al final de la cadena:

`MJQXGZJTGIQGS4ZAON2XAZLSEBRW63LNN5XCA2LOEBBVIRRHOM======`

*Base64* incluye todas las mayúsculas y minúsculas, ademas solo puede poseer hasta 2 simbolos `=` al final y no más.

`RWFjaCBCYXNlNjQgZGlnaXQgcmVwcmVzZW50cyBleGFjdGx5IDYgYml0cyBvZiBkYXRhLg==`

### Hexadecimal

> Para decodificar **hexadecimal** existe el comando `xxd`, cabe recalcar que esta hecho para mostrar un **hexdump** de archivos, por lo que es ***importante*** agregar la bandera `-p` para codificar/decodificar texto plano.

La bandera que especifíca que es una decodificación es `-r`.

```bash
echo -n "486f6c61" | xxd -p -r
# > Hola
```

### Binario

> Si hallamos secuencias de bloques de bits separados por espacios, es común que estos bloques sean de ***8*** bits (un *byte*) y que representen el código *ASCII* de algun caracter.

Entonces podriamos tener un mensaje codificado en **binario**.

No hallé una herramienta simple para decodificar este tipo de mensajes pero realicé un pequeño *Script* en *Python* que lo realiza de una manera que me pareció fácil de entender.

```bash
#---------------------------------------------------------
# bin2ascii.py
#---------------------------------------------------------

#!/sbin/python

# Imports
import argparse

# Configuración del parser
parser = argparse.ArgumentParser(description="Script simple para pasar binario a hexadecimal")
parser.add_argument("payload", type=str, help="Cadena por decodificar")
parser.add_argument("--separator",'-s',type=str, help="Caracter que separa los bloques de bits")

# Obtención de argumentos
args = parser.parse_args()

# Variables
separador = args.separator
mensaje = args.payload

if separador is None:
    caracs = [mensaje[i:i+8] for i in range(0,len(mensaje),8)]
    print(''.join([chr(int(c,2)) for c in caracs]), end='')
else:
    caracs = mensaje.split(separador)
    print(''.join([chr(int(c,2)) for c in caracs]), end='')
```

**Terminal**:

```bash
./bin2ascii.py "01001000 01101111 01101100 01100001"
# > Hola
```

### Rot13

> El clásico rotacional 13 que desplaza 13 posiciones (del alfabeto) las letras del mensaje original, respetando mayúsculas y minúsculas.

Para descifrar (o cifrar) este tipo de mensajes, existe el comando `rot13`, aunque probablemente se tenga que instalar:

```bash
echo "Ubyn" | rot13
# > Hola
```

Cabe mencionar que el comando `rot13`, simplemente esta realizando una configuración específica del comando `tr`, herramienta básica de todas las máquinas *UNIX*:

```bash
echo "Ubyn" | tr 'A-Za-z' 'N-ZA-Mn-za-m'
# > Hola
```

Con cualquiera de los 2 comandos se cumple el mismo objetivo.

### Rot47

> Similar a **Rot13** pero rota 47 posiciones (del alfabeto más cierta selección de simbolos especiales) los caracteres del mensaje original.

Para lograr esta decodificación (o codificación), podemos recurrir de nuevo al comando `tr`:

```bash
echo "w@=2" | tr '\!-~' 'P-~\!-O'
# > Hola
```

# Enlaces

[Esteganografía ->](Esteganografia.md)